<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sticker Tempel Text</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
    <div id="root"></div>
    
    <script type="text/babel">
const { useState, useRef, useEffect } = React;

const MemeMaker = () => {
  const [image, setImage] = useState(null);
  const [isGif, setIsGif] = useState(false);
  const [texts, setTexts] = useState([]);
  const [fontSize, setFontSize] = useState(48);
  const [fontFamily, setFontFamily] = useState('Impact');
  const [uploadedFontName, setUploadedFontName] = useState('');
  const [outlineWidth, setOutlineWidth] = useState(3);
  const [imageScale, setImageScale] = useState(1);
  const [dragging, setDragging] = useState(null);
  const [scaling, setScaling] = useState(null);
  const [initialPinchDist, setInitialPinchDist] = useState(null);
  const [riccoClicks, setRiccoClicks] = useState(0);
  const [isAnimating, setIsAnimating] = useState(false);
  const [stickerImages, setStickerImages] = useState([]);
  const [downloadFilename, setDownloadFilename] = useState('meme');
  const canvasRef = useRef(null);
  const fileInputRef = useRef(null);
  const stickerInputRef = useRef(null);
  const fontInputRef = useRef(null);

  useEffect(() => {
    if (image) {
      drawMeme();
    }
  }, [image, texts, fontSize, fontFamily, uploadedFontName, outlineWidth, imageScale, stickerImages]);

  const handleImageUpload = (e) => {
    const file = e.target.files[0];
    if (file) {
      const isGifFile = file.type === 'image/gif';
      setIsGif(isGifFile);
      
      const reader = new FileReader();
      reader.onload = (event) => {
        const img = new Image();
        img.onload = () => {
          setImage(img);
        };
        img.src = event.target.result;
      };
      reader.readAsDataURL(file);
    }
  };

  const handleImageFromUrl = (url) => {
    if (url && (url.startsWith('http://') || url.startsWith('https://'))) {
      const isGifFile = url.toLowerCase().endsWith('.gif');
      setIsGif(isGifFile);
      
      const img = new Image();
      img.crossOrigin = 'anonymous';
      img.onload = () => {
        setImage(img);
      };
      img.onerror = () => {
        alert('Gagal load gambar dari URL. Pastikan link valid dan bisa diakses.');
      };
      img.src = url;
    }
  };

  const handleStickerUpload = (e) => {
    const file = e.target.files[0];
    if (file) {
      const reader = new FileReader();
      reader.onload = (event) => {
        const img = new Image();
        img.onload = () => {
          setStickerImages([...stickerImages, {
            img,
            x: 0.5,
            y: 0.5,
            size: 0.2,
            id: Date.now()
          }]);
        };
        img.src = event.target.result;
      };
      reader.readAsDataURL(file);
    }
  };

  const handleFontUpload = (e) => {
    const file = e.target.files[0];
    if (file && (file.name.endsWith('.ttf') || file.name.endsWith('.otf') || file.name.endsWith('.woff') || file.name.endsWith('.woff2'))) {
      const reader = new FileReader();
      reader.onload = (event) => {
        const fontName = `CustomFont_${Date.now()}`;
        const fontFace = new FontFace(fontName, `url(${event.target.result})`);
        
        fontFace.load().then((loadedFont) => {
          document.fonts.add(loadedFont);
          setUploadedFontName(fontName);
          alert(`Font "${file.name}" berhasil diupload!`);
        }).catch((error) => {
          console.error('Error loading font:', error);
          alert('Gagal load font. Pastikan file format benar (.ttf, .otf, .woff, .woff2)');
        });
      };
      reader.readAsDataURL(file);
    } else {
      alert('File harus format .ttf, .otf, .woff, atau .woff2');
    }
  };

  const drawMeme = () => {
    const canvas = canvasRef.current;
    if (!canvas || !image) return;

    const ctx = canvas.getContext('2d');
    
    const maxWidth = 800;
    const maxHeight = 800;
    let width = image.width * imageScale;
    let height = image.height * imageScale;

    if (width > maxWidth || height > maxHeight) {
      const ratio = Math.min(maxWidth / width, maxHeight / height);
      width *= ratio;
      height *= ratio;
    }

    canvas.width = width;
    canvas.height = height;

    ctx.drawImage(image, 0, 0, width, height);

    stickerImages.forEach(sticker => {
      if (sticker.img && sticker.img.complete) {
        const stickerWidth = sticker.size * width;
        const stickerHeight = (sticker.img.height / sticker.img.width) * stickerWidth;
        const x = sticker.x * width - stickerWidth / 2;
        const y = sticker.y * height - stickerHeight / 2;
        ctx.drawImage(sticker.img, x, y, stickerWidth, stickerHeight);
      }
    });

    const finalFont = uploadedFontName || fontFamily;
    ctx.fillStyle = 'white';
    ctx.strokeStyle = 'black';
    ctx.lineWidth = outlineWidth;
    ctx.textAlign = 'center';

    texts.forEach(textObj => {
      if (textObj.text) {
        const scaledFontSize = textObj.fontSize * textObj.scale;
        ctx.font = `bold ${scaledFontSize}px ${finalFont}, Arial Black, sans-serif`;
        const lines = wrapText(ctx, textObj.text.toUpperCase(), width - 20);
        const startY = textObj.y * height;
        lines.forEach((line, index) => {
          const y = startY + (index * scaledFontSize * 1.1);
          const x = textObj.x * width;
          ctx.strokeText(line, x, y);
          ctx.fillText(line, x, y);
        });
      }
    });
  };

  const wrapText = (ctx, text, maxWidth) => {
    const words = text.split(' ');
    const lines = [];
    let currentLine = words[0];

    for (let i = 1; i < words.length; i++) {
      const word = words[i];
      const width = ctx.measureText(currentLine + ' ' + word).width;
      if (width < maxWidth) {
        currentLine += ' ' + word;
      } else {
        lines.push(currentLine);
        currentLine = word;
      }
    }
    lines.push(currentLine);
    return lines;
  };

  const downloadMeme = () => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const extension = isGif ? 'gif' : 'png';
    const filename = downloadFilename.trim() || 'meme';

    canvas.toBlob((blob) => {
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.download = `${filename}.${extension}`;
      link.href = url;
      link.click();
      URL.revokeObjectURL(url);
    }, `image/${extension}`);
  };

  const resetMeme = () => {
    setImage(null);
    setIsGif(false);
    setTexts([]);
    setFontSize(48);
    setFontFamily('Impact');
    setUploadedFontName('');
    setOutlineWidth(3);
    setImageScale(1);
    setStickerImages([]);
    setDownloadFilename('meme');
    if (fileInputRef.current) fileInputRef.current.value = '';
    if (stickerInputRef.current) stickerInputRef.current.value = '';
    if (fontInputRef.current) fontInputRef.current.value = '';
  };

  const handleMouseMove = (e) => {
    if (!canvasRef.current) return;
    
    const canvas = canvasRef.current;
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) / rect.width;
    const y = (e.clientY - rect.top) / rect.height;
    
    if (dragging && dragging.startsWith('text-')) {
      const textId = parseInt(dragging.split('-')[1]);
      setTexts(texts.map(t => 
        t.id === textId ? { ...t, x: Math.max(0, Math.min(1, x)), y: Math.max(0, Math.min(1, y)) } : t
      ));
    } else if (dragging && dragging.startsWith('sticker-')) {
      const stickerId = parseInt(dragging.split('-')[1]);
      setStickerImages(stickerImages.map(s => 
        s.id === stickerId ? { ...s, x: Math.max(0, Math.min(1, x)), y: Math.max(0, Math.min(1, y)) } : s
      ));
    }
    
    if (scaling && scaling.startsWith('text-') && e.buttons === 2) {
      const textId = parseInt(scaling.split('-')[1]);
      setTexts(texts.map(t => {
        if (t.id === textId) {
          const centerDist = Math.sqrt(Math.pow(x - t.x, 2) + Math.pow(y - t.y, 2));
          return { ...t, scale: Math.max(0.3, Math.min(3, centerDist * 5)) };
        }
        return t;
      }));
    } else if (scaling && scaling.startsWith('sticker-') && e.buttons === 2) {
      const stickerId = parseInt(scaling.split('-')[1]);
      setStickerImages(stickerImages.map(s => {
        if (s.id === stickerId) {
          const centerDist = Math.sqrt(Math.pow(x - s.x, 2) + Math.pow(y - s.y, 2));
          return { ...s, size: Math.max(0.05, Math.min(0.8, centerDist * 2)) };
        }
        return s;
      }));
    }
  };

  const handleTouchMove = (e) => {
    if (!canvasRef.current) return;
    
    const canvas = canvasRef.current;
    const rect = canvas.getBoundingClientRect();
    
    if (e.touches.length === 2 && scaling === 'image') {
      e.preventDefault();
      const touch1 = e.touches[0];
      const touch2 = e.touches[1];
      const dist = Math.hypot(
        touch1.clientX - touch2.clientX,
        touch1.clientY - touch2.clientY
      );
      
      if (initialPinchDist) {
        const scale = dist / initialPinchDist;
        setImageScale(prev => Math.max(0.3, Math.min(3, prev * scale)));
        setInitialPinchDist(dist);
      }
      return;
    }
    
    if (e.touches.length === 2 && scaling && scaling.startsWith('sticker-')) {
      e.preventDefault();
      const touch1 = e.touches[0];
      const touch2 = e.touches[1];
      const dist = Math.hypot(
        touch1.clientX - touch2.clientX,
        touch1.clientY - touch2.clientY
      );
      
      if (initialPinchDist) {
        const scale = dist / initialPinchDist;
        const stickerId = parseInt(scaling.split('-')[1]);
        setStickerImages(stickerImages.map(s => {
          if (s.id === stickerId) {
            return { ...s, size: Math.max(0.05, Math.min(0.8, s.size * scale)) };
          }
          return s;
        }));
        setInitialPinchDist(dist);
      }
      return;
    }
    
    if (e.touches.length === 2 && scaling && scaling.startsWith('text-')) {
      e.preventDefault();
      const touch1 = e.touches[0];
      const touch2 = e.touches[1];
      const dist = Math.hypot(
        touch1.clientX - touch2.clientX,
        touch1.clientY - touch2.clientY
      );
      
      if (initialPinchDist) {
        const scale = dist / initialPinchDist;
        const textId = parseInt(scaling.split('-')[1]);
        setTexts(texts.map(t => {
          if (t.id === textId) {
            return { ...t, scale: Math.max(0.3, Math.min(3, t.scale * scale)) };
          }
          return t;
        }));
        setInitialPinchDist(dist);
      }
      return;
    }
    
    if (e.touches.length === 1) {
      e.preventDefault();
      const touch = e.touches[0];
      const x = (touch.clientX - rect.left) / rect.width;
      const y = (touch.clientY - rect.top) / rect.height;
      
      if (dragging && dragging.startsWith('text-')) {
        const textId = parseInt(dragging.split('-')[1]);
        setTexts(texts.map(t => 
          t.id === textId ? { ...t, x: Math.max(0, Math.min(1, x)), y: Math.max(0, Math.min(1, y)) } : t
        ));
      } else if (dragging && dragging.startsWith('sticker-')) {
        const stickerId = parseInt(dragging.split('-')[1]);
        setStickerImages(stickerImages.map(s => 
          s.id === stickerId ? { ...s, x: Math.max(0, Math.min(1, x)), y: Math.max(0, Math.min(1, y)) } : s
        ));
      }
    }
  };

  const handleMouseUp = () => {
    setDragging(null);
    setScaling(null);
    setInitialPinchDist(null);
  };

  const handleRiccoClick = () => {
    setRiccoClicks(prev => prev + 1);
    setIsAnimating(true);
    setTimeout(() => setIsAnimating(false), 500);
  };

  return (
    <div className="min-h-screen relative p-4" style={{
      backgroundImage: 'url(https://i.imgur.com/USMJ1K3.png)',
      backgroundSize: 'cover',
      backgroundPosition: 'center',
      backgroundRepeat: 'no-repeat',
      backgroundAttachment: 'fixed'
    }}>
      <style>{`
        @keyframes bounce {
          0%, 100% { transform: translateY(0); }
          50% { transform: translateY(-10px); }
        }
        @keyframes shake {
          0%, 100% { transform: rotate(0deg); }
          25% { transform: rotate(-5deg); }
          75% { transform: rotate(5deg); }
        }
        @keyframes pulse {
          0%, 100% { transform: scale(1); }
          50% { transform: scale(1.05); }
        }
        .animate-bounce-slow {
          animation: bounce 2s ease-in-out infinite;
        }
        .animate-shake {
          animation: shake 0.5s ease-in-out;
        }
        .animate-pulse-slow {
          animation: pulse 2s ease-in-out infinite;
        }
      `}</style>
      <div className="absolute inset-0 bg-black/20"></div>
      <div className="max-w-6xl mx-auto relative z-10">
        <div className="text-center mb-8 animate-bounce-slow">
          <h1 className="text-5xl font-black text-white mb-2 drop-shadow-lg" style={{textShadow: '4px 4px 8px rgba(0,0,0,0.8)'}}>STICKER TEMPEL TEXT</h1>
          <p className="text-white text-lg font-bold" style={{textShadow: '2px 2px 4px rgba(0,0,0,0.8)'}}>INI BUAT TEMPEL TEXT YGY!</p>
        </div>

        <div className="grid md:grid-cols-2 gap-6">
          <div className="space-y-4">
            <div className="bg-white rounded-2xl p-6 shadow-2xl transform hover:scale-105 transition-transform duration-300">
              <h2 className="text-2xl font-bold text-black mb-4">ðŸ“· Tempel Sticker/Gambar</h2>
              
              <input
                ref={stickerInputRef}
                type="file"
                accept="image/*"
                onChange={handleStickerUpload}
                className="hidden"
                id="sticker-upload"
              />
              
              <label
                htmlFor="sticker-upload"
                className="block w-full bg-gradient-to-r from-pink-500 to-purple-600 text-white px-6 py-4 rounded-xl font-bold text-center cursor-pointer hover:shadow-xl transform hover:scale-105 transition-all duration-300"
              >
                + Tambah Sticker
              </label>
              
              {stickerImages.length > 0 && (
                <div className="mt-4 space-y-2">
                  <p className="text-sm font-bold text-black">Sticker Aktif: {stickerImages.length}</p>
                  
                  {stickerImages.map((sticker, index) => (
                    <div key={sticker.id} className="bg-gray-100 p-3 rounded-lg">
                      <div className="flex justify-between items-center mb-2">
                        <span className="text-xs font-bold">Sticker {index + 1}</span>
                        <button
                          onClick={() => setStickerImages(stickerImages.filter(s => s.id !== sticker.id))}
                          className="text-xs bg-red-500 text-white px-2 py-1 rounded hover:bg-red-600"
                        >
                          âœ– Hapus
                        </button>
                      </div>
                      <label className="block text-xs font-bold text-black mb-1">Ukuran: {(sticker.size * 100).toFixed(0)}%</label>
                      <input
                        type="range"
                        min="5"
                        max="80"
                        value={sticker.size * 100}
                        onChange={(e) => {
                          const newSize = parseInt(e.target.value) / 100;
                          setStickerImages(stickerImages.map(s => 
                            s.id === sticker.id ? { ...s, size: newSize } : s
                          ));
                        }}
                        className="w-full"
                      />
                    </div>
                  ))}
                  
                  <button
                    onClick={() => setStickerImages([])}
                    className="w-full bg-red-500 text-white px-4 py-2 rounded-lg font-bold hover:bg-red-600 transition-all duration-300"
                  >
                    Hapus Semua Sticker
                  </button>
                </div>
              )}
            </div>
            
            <div className="bg-white rounded-2xl p-6 shadow-2xl transform hover:scale-105 transition-transform duration-300">
              <h2 className="text-2xl font-bold text-black mb-4">Upload Gambar</h2>
              
              <input
                ref={fileInputRef}
                type="file"
                accept="image/*"
                onChange={handleImageUpload}
                className="hidden"
                id="file-upload"
              />
              
              <label
                htmlFor="file-upload"
                className="block w-full bg-gradient-to-r from-blue-500 to-blue-600 text-white px-6 py-4 rounded-xl font-bold text-center cursor-pointer hover:shadow-lg transform hover:scale-105 transition mb-3"
              >
                Pilih Gambar
              </label>

              <div className="relative">
                <input
                  type="text"
                  placeholder="Atau paste link gambar disini..."
                  className="w-full px-4 py-3 border-2 border-gray-300 rounded-lg focus:border-blue-500 focus:outline-none transition-all duration-300"
                  onPaste={(e) => {
                    const url = e.clipboardData.getData('text');
                    handleImageFromUrl(url);
                    e.target.value = url;
                  }}
                  onKeyDown={(e) => {
                    if (e.key === 'Enter') {
                      handleImageFromUrl(e.target.value);
                    }
                  }}
                />
              </div>

              {image && (
                <div className="mt-3">
                  <label className="block text-sm font-bold text-black mb-2">Ukuran Gambar: {(imageScale * 100).toFixed(0)}%</label>
                  <input
                    type="range"
                    min="30"
                    max="300"
                    value={imageScale * 100}
                    onChange={(e) => setImageScale(parseInt(e.target.value) / 100)}
                    className="w-full"
                  />
                </div>
              )}
            </div>

            <div className="bg-white rounded-2xl p-6 shadow-2xl transform hover:scale-105 transition-transform duration-300">
              <h2 className="text-2xl font-bold text-black mb-4">TEXT</h2>
              
              <div className="space-y-4">
                <button
                  onClick={() => {
                    setTexts([...texts, {
                      id: Date.now(),
                      text: '',
                      x: 0.5,
                      y: texts.length === 0 ? 0.15 : 0.5,
                      scale: 1,
                      fontSize: fontSize
                    }]);
                  }}
                  className="w-full bg-gradient-to-r from-green-500 to-green-600 text-white px-6 py-4 rounded-xl font-bold hover:shadow-xl transform hover:scale-105 transition-all duration-300"
                >
                  + Tambah Text
                </button>

                {texts.map((textObj, index) => (
                  <div key={textObj.id} className="bg-gray-100 p-4 rounded-lg space-y-3">
                    <div className="flex justify-between items-center">
                      <span className="text-sm font-bold text-black">Text {index + 1}</span>
                      <button
                        onClick={() => setTexts(texts.filter(t => t.id !== textObj.id))}
                        className="text-xs bg-red-500 text-white px-2 py-1 rounded hover:bg-red-600"
                      >
                        âœ– Hapus
                      </button>
                    </div>
                    
                    <input
                      type="text"
                      value={textObj.text}
                      onChange={(e) => {
                        setTexts(texts.map(t => 
                          t.id === textObj.id ? { ...t, text: e.target.value } : t
                        ));
                      }}
                      placeholder="TULIS TEXT DISINI"
                      className="w-full px-4 py-3 border-2 border-gray-300 rounded-lg focus:border-purple-500 focus:outline-none font-bold uppercase transition-all duration-300"
                    />

                    <div>
                      <label className="block text-xs font-bold text-black mb-1">Ukuran Font: {textObj.fontSize}px</label>
                      <input
                        type="range"
                        min="20"
                        max="100"
                        value={textObj.fontSize}
                        onChange={(e) => {
                          setTexts(texts.map(t => 
                            t.id === textObj.id ? { ...t, fontSize: parseInt(e.target.value) } : t
                          ));
                        }}
                        className="w-full"
                      />
                    </div>

                    <div>
                      <label className="block text-xs font-bold text-black mb-1">Scale: {(textObj.scale * 100).toFixed(0)}%</label>
                      <input
                        type="range"
                        min="30"
                        max="300"
                        value={textObj.scale * 100}
                        onChange={(e) => {
                          setTexts(texts.map(t => 
                            t.id === textObj.id ? { ...t, scale: parseInt(e.target.value) / 100 } : t
                          ));
                        }}
                        className="w-full"
                      />
                    </div>
                  </div>
                ))}

                <div>
                  <label className="block text-sm font-bold text-black mb-2">Pilih Font</label>
                  <select
                    value={fontFamily}
                    onChange={(e) => setFontFamily(e.target.value)}
                    disabled={uploadedFontName !== ''}
                    className="w-full px-4 py-3 border-2 border-gray-300 rounded-lg focus:border-purple-500 focus:outline-none font-bold transition-all duration-300 disabled:bg-gray-200"
                  >
                    <option value="Impact">Impact</option>
                    <option value="Arial Black">Arial Black</option>
                    <option value="Comic Sans MS">Comic Sans MS</option>
                    <option value="Courier New">Courier New</option>
                    <option value="Georgia">Georgia</option>
                    <option value="Times New Roman">Times New Roman</option>
                    <option value="Verdana">Verdana</option>
                  </select>
                </div>

                <div>
                  <label className="block text-sm font-bold text-black mb-2">Upload Font Custom</label>
                  
                  <input
                    ref={fontInputRef}
                    type="file"
                    accept=".ttf,.otf,.woff,.woff2"
                    onChange={handleFontUpload}
                    className="hidden"
                    id="font-upload"
                  />
                  
                  <label
                    htmlFor="font-upload"
                    className="block w-full bg-gradient-to-r from-indigo-500 to-purple-600 text-white px-4 py-3 rounded-lg font-bold text-center cursor-pointer hover:shadow-lg transform hover:scale-105 transition-all duration-300"
                  >
                    {uploadedFontName ? 'âœ“ Font Terupload' : 'Pilih Custom Font'}
                  </label>
                  
                  {uploadedFontName && (
                    <div className="mt-2 flex items-center justify-between bg-green-100 px-3 py-2 rounded-lg">
                      <span className="text-xs font-bold text-green-800">Font custom aktif!</span>
                      <button
                        onClick={() => setUploadedFontName('')}
                        className="text-xs bg-red-500 text-white px-2 py-1 rounded hover:bg-red-600"
                      >
                       âœ– Hapus
                      </button>
                    </div>
                  )}
                </div>

                <div>
                  <label className="block text-sm font-bold text-black mb-2">Ketebalan Outline: {outlineWidth}px</label>
                  <input
                    type="range"
                    min="1"
                    max="10"
                    value={outlineWidth}
                    onChange={(e) => setOutlineWidth(parseInt(e.target.value))}
                    className="w-full"
                  />
                </div>

                <div>
                  <label className="block text-sm font-bold text-black mb-2">Nama File Download</label>
                  <input
                    type="text"
                    value={downloadFilename}
                    onChange={(e) => setDownloadFilename(e.target.value)}
                    placeholder="meme"
                    className="w-full px-4 py-3 border-2 border-gray-300 rounded-lg focus:border-purple-500 focus:outline-none font-bold transition-all duration-300"
                  />
                  <p className="text-xs text-gray-600 mt-1">File akan disimpan sebagai: {downloadFilename || 'meme'}.{isGif ? 'gif' : 'png'}</p>
                </div>
              </div>
            </div>

            <div className="bg-gradient-to-r from-yellow-400 to-orange-500 rounded-2xl p-4 shadow-2xl">
              <p className="text-sm font-bold text-white text-center mb-1">ðŸ’¡ Desktop: Klik kanan + drag = resize</p>
              <p className="text-sm font-bold text-white text-center">ðŸ“± Mobile: Pinch zoom (2 jari) = resize</p>
            </div>

            <div className="bg-white rounded-2xl p-6 shadow-2xl transform hover:scale-105 transition-transform duration-300">
              <div className="grid grid-cols-2 gap-3">
                <button
                  onClick={downloadMeme}
                  disabled={!image}
                  className={`px-6 py-4 rounded-xl font-bold text-white transition-all duration-300 active:scale-95 ${
                    image
                      ? 'bg-gradient-to-r from-green-500 to-green-600 hover:shadow-2xl animate-pulse-slow'
                      : 'bg-gray-400 cursor-not-allowed'
                  }`}
                >
                  â¤µ Download
                </button>
                
                <button
                  onClick={resetMeme}
                  className="bg-gradient-to-r from-red-500 to-red-600 text-white px-6 py-4 rounded-xl font-bold hover:shadow-2xl active:scale-95 transition-all duration-300"
                >
                  â†» Reset
                </button>
              </div>
            </div>
          </div>

          <div className="bg-white rounded-2xl p-6 shadow-2xl transform hover:scale-105 transition-transform duration-300">
            <h2 className="text-2xl font-bold text-black mb-4">Preview Sticker</h2>
            
            <div className="bg-gray-100 rounded-xl overflow-hidden flex items-center justify-center min-h-[400px]">
              {image ? (
                <div 
                  className="relative"
                  onMouseMove={handleMouseMove}
                  onMouseUp={handleMouseUp}
                  onMouseLeave={handleMouseUp}
                  onTouchMove={handleTouchMove}
                  onTouchEnd={handleMouseUp}
                >
                  <canvas
                    ref={canvasRef}
                    className="max-w-full h-auto cursor-move"
                    onMouseDown={(e) => {
                      e.preventDefault();
                      const canvas = canvasRef.current;
                      const rect = canvas.getBoundingClientRect();
                      const x = (e.clientX - rect.left) / rect.width;
                      const y = (e.clientY - rect.top) / rect.height;
                      const isRightClick = e.button === 2;
                      
                      for (let i = stickerImages.length - 1; i >= 0; i--) {
                        const sticker = stickerImages[i];
                        const stickerWidth = sticker.size;
                        const stickerHeight = sticker.size * (sticker.img.height / sticker.img.width);
                        const distX = Math.abs(x - sticker.x);
                        const distY = Math.abs(y - sticker.y);
                        
                        if (distX < stickerWidth / 2 && distY < stickerHeight / 2) {
                          if (isRightClick) {
                            setScaling(`sticker-${sticker.id}`);
                          } else {
                            setDragging(`sticker-${sticker.id}`);
                          }
                          return;
                        }
                      }
                      
                      for (let i = texts.length - 1; i >= 0; i--) {
                        const text = texts[i];
                        const dist = Math.sqrt(Math.pow(x - text.x, 2) + Math.pow(y - text.y, 2));
                        
                        if (text.text && dist < 0.1) {
                          if (isRightClick) {
                            setScaling(`text-${text.id}`);
                          } else {
                            setDragging(`text-${text.id}`);
                          }
                          return;
                        }
                      }
                    }}
                    onContextMenu={(e) => e.preventDefault()}
                    onTouchStart={(e) => {
                      const canvas = canvasRef.current;
                      const rect = canvas.getBoundingClientRect();
                      
                      if (e.touches.length === 2) {
                        const touch1 = e.touches[0];
                        const touch2 = e.touches[1];
                        const dist = Math.hypot(
                          touch1.clientX - touch2.clientX,
                          touch1.clientY - touch2.clientY
                        );
                        setInitialPinchDist(dist);
                        
                        const centerX = ((touch1.clientX + touch2.clientX) / 2 - rect.left) / rect.width;
                        const centerY = ((touch1.clientY + touch2.clientY) / 2 - rect.top) / rect.height;
                        
                        for (let i = stickerImages.length - 1; i >= 0; i--) {
                          const sticker = stickerImages[i];
                          const stickerWidth = sticker.size;
                          const stickerHeight = sticker.size * (sticker.img.height / sticker.img.width);
                          const distX = Math.abs(centerX - sticker.x);
                          const distY = Math.abs(centerY - sticker.y);
                          
                          if (distX < stickerWidth / 2 && distY < stickerHeight / 2) {
                            setScaling(`sticker-${sticker.id}`);
                            return;
                          }
                        }
                        
                        for (let i = texts.length - 1; i >= 0; i--) {
                          const text = texts[i];
                          const dist = Math.sqrt(Math.pow(centerX - text.x, 2) + Math.pow(centerY - text.y, 2));
                          
                          if (text.text && dist < 0.1) {
                            setScaling(`text-${text.id}`);
                            return;
                          }
                        }
                        
                        setScaling('image');
                        return;
                      }
                      
                      const touch = e.touches[0];
                      const x = (touch.clientX - rect.left) / rect.width;
                      const y = (touch.clientY - rect.top) / rect.height;
                      
                      for (let i = stickerImages.length - 1; i >= 0; i--) {
                        const sticker = stickerImages[i];
                        const stickerWidth = sticker.size;
                        const stickerHeight = sticker.size * (sticker.img.height / sticker.img.width);
                        const distX = Math.abs(x - sticker.x);
                        const distY = Math.abs(y - sticker.y);
                        
                        if (distX < stickerWidth / 2 && distY < stickerHeight / 2) {
                          setDragging(`sticker-${sticker.id}`);
                          return;
                        }
                      }
                      
                      for (let i = texts.length - 1; i >= 0; i--) {
                        const text = texts[i];
                        const dist = Math.sqrt(Math.pow(x - text.x, 2) + Math.pow(y - text.y, 2));
                        
                        if (text.text && dist < 0.1) {
                          setDragging(`text-${text.id}`);
                          return;
                        }
                      }
                    }}
                    onWheel={(e) => {
                      if (e.ctrlKey || e.metaKey) {
                        e.preventDefault();
                        const delta = e.deltaY > 0 ? 0.95 : 1.05;
                        setImageScale(prev => Math.max(0.3, Math.min(3, prev * delta)));
                      }
                    }}
                  />
                </div>
              ) : (
                <div className="text-center text-gray-400 p-8">
                  <div className="text-6xl mb-4 animate-bounce-slow">ðŸ“·</div>
                  <p className="text-lg font-bold text-black">Upload Dulu Gambarnya wok</p>
                </div>
              )}
            </div>
          </div>
        </div>

        <div 
          onClick={handleRiccoClick}
          className={`mt-6 bg-white/20 backdrop-blur-md rounded-2xl p-4 text-white text-center border-2 border-white/30 cursor-pointer hover:bg-white/30 transition-all duration-300 ${isAnimating ? 'animate-shake' : ''}`}
        >
          <p className="text-xl font-black" style={{textShadow: '2px 2px 4px rgba(0,0,0,0.8)'}}>
            {riccoClicks > 0 ? 'RIKKIUU' : 'RICCO'}
          </p>
        </div>
      </div>
    </div>
  );
};

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<MemeMaker />);
    </script>
</body>
</html>
